# Реализация Trie и Graph на Java с использованием собственных коллекций

## Общее описание

Проект содержит реализацию двух структур данных:

* **Trie** (префиксное дерево)
* **Graph** (ориентированный и неориентированный граф)

* интерфейс списка `MyList`
* динамический массив `MyArrayList`

Обе структуры данных используют эти коллекции для хранения информации и работы с элементами.

---

# Описание файлов

## 1. **MyList.java**

**Тип:** интерфейс (generic)
**Назначение:**

* задаёт контракт для всех самописных списков;
* используется Trie и Graph как универсальный тип коллекции.

Методы:

* `add(T value)` — добавить элемент
* `get(int index)` — получить по индексу
* `size()` — вернуть размер
* `isEmpty()` — проверить пустоту

Файл **не содержит реализации**, только определяет общую структуру.

---

## 2. **MyArrayList.java**

**Тип:** класс (generic)
**Назначение:**

* собственная реализация динамического массива без использования `ArrayList`
* расширяется автоматически при нехватке места
* работает через `Object[]` с преобразованием типов

Методы:

* `add(T value)` — добавление элемента
* `get(int index)` — получение элемента
* `size()` — текущий размер
* `isEmpty()` — проверка на пустоту
* автоматическое расширение массива при заполнении

Используется:

* для хранения результатов в Trie
* для хранения соседей в Graph
* как основная коллекция проекта

---

## 3. **Trie.java**

**Тип:** структура данных (префиксное дерево)
**Назначение:**

* хранение строк из букв `a–z`
* быстрые операции поиска слова и поиска по префиксу

Реализует функции по заданию:

1. **`void insert(String word)`**
   Вставляет слово в Trie, создаёт узлы при необходимости.

2. **`boolean contains(String word)`**
   Проверяет, существует ли слово **полностью**.

3. **`boolean startsWith(String prefix)`**
   Проверяет, существует ли хотя бы одно слово с данным префиксом.

4. **`MyList<String> getByPrefix(String prefix)`**
   Возвращает все слова, начинающиеся на переданный префикс.

Дополнительно:

* реализована рекурсия для обхода поддерева (`collect`)
* есть свой `Node` с массивом `Node[26]`
* есть проверка корректности входных данных
* содержит метод `main()` для демонстрации работы

---

## 4. **Graph.java**

**Тип:** структура данных (граф)
**Назначение:**

* создание ориентированных и неориентированных графов
* хранение вершин и списка их соседей
* работа через самописные коллекции

Функциональность:

1. **`int addVertex(T value)`**
   Добавляет вершину, возвращает её индекс.

2. **`void addEdge(int from, int to)`**
   Добавляет ребро между вершинами.

   * Если граф **неориентированный**, добавляется в обе стороны.

3. **`MyList<Integer> getNeighbors(int index)`**
   Возвращает список индексов соседних вершин.

4. **`MyList<T> getNeighborValues(int index)`**
   Возвращает значения соседних вершин (например: `["B", "C"]`).

5. **`int vertexCount()`**
   Возвращает количество вершин в графе.

Файл также содержит `main()` с примером работы.

---

# Компиляция

```bash
javac MyList.java myArrayList.java Trie.java graph.java
```

---

# Запуск Trie

```bash
java Trie
```

Ожидаемый вывод:

```
true
false
true
[app, apple, application]
[banana]
[banana]
[]
```

---

# Запуск Graph

```bash
java graph
```

Ожидаемый вывод:

```
Вершин: 3
Соседи A (индексы): [1, 2]
Соседи A (значения): [B, C]
```

---
## Автор

**Иванов Кирилл Николаевич, 24КНТ-1**
